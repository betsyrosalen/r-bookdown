[
["intro.html", "tidyverse Book 1 Introduction 1.1 Core tidyverse", " tidyverse Book CUNY SPS DATA 607 Spring 2018 2018-05-09 1 Introduction 1.1 Core tidyverse Some quotes and concepts from Hadley Wickham that we may want to include in the intro… 1.1.0.1 Data semantics A dataset is a collection of values, usually either numbers (if quantitative) or strings (if qualitative). Values are organised in two ways. Every value belongs to a variable and an observation. A variable contains all values that measure the same underlying attribute (like height, temperature, duration) across units. An observation contains all values measured on the same unit (like a person, or a day, or a race) across attributes. The experimental design also determines whether or not missing values can be safely dropped. In this experiment, the missing value represents an observation that should have been made, but wasn’t, so it’s important to keep it. Structural missing values, which represent measurements that can’t be made (e.g., the count of pregnant males) can be safely removed. A general rule of thumb is that it is easier to describe functional relationships between variables (e.g., z is a linear combination of x and y, density is the ratio of weight to volume) than between rows, and it is easier to make comparisons between groups of observations (e.g., average of group a vs. average of group b) than between groups of columns. 1.1.0.2 Tidy data Tidy data is a standard way of mapping the meaning of a dataset to its structure. A dataset is messy or tidy depending on how rows, columns and tables are matched up with observations, variables and types. In tidy data: 1. Each variable forms a column. 2. Each observation forms a row. 3. Each type of observational unit forms a table. This is Codd’s 3rd normal form, but with the constraints framed in statistical language, and the focus put on a single dataset rather than the many connected datasets common in relational databases. Messy data is any other arrangement of the data. Alternate Definition from Garrett Grolemund R follows a set of conventions that makes one layout of tabular data much easier to work with than others. Your data will be easier to work with in R if it follows three rules 1. Each variable in the data set is placed in its own column 2. Each observation is placed in its own row 3. Each value is placed in its own cell* Data that satisfies these rules is known as tidy data. five most common problems with messy datasets…: 1. Column headers are values, not variable names. 2. Multiple variables are stored in one column. 3. Variables are stored in both rows and columns. 4. Multiple types of observational units are stored in the same table. 5. A single observational unit is stored in multiple tables. 1.1.0.3 Normalization Normalisation is useful for tidying and eliminating inconsistencies. However, there are few data analysis tools that work directly with relational data, so analysis usually also requires denormalisation or the merging the datasets back into one table. "],
["ggplot2.html", "2 ggplot2 2.1 +.gg () 2.2 aes () 2.3 aes_ () 2.4 aes_colour_fill_alpha () 2.5 aes_group_order () 2.6 aes_linetype_size_shape () 2.7 aes_position () 2.8 annotate () 2.9 annotation_custom () 2.10 annotation_logticks () 2.11 annotation_map () 2.12 annotation_raster () 2.13 autoplot () 2.14 borders () 2.15 coord_cartesian () 2.16 coord_fixed () 2.17 coord_flip () 2.18 coord_map () 2.19 coord_polar () 2.20 coord_trans () 2.21 cut_interval () 2.22 diamonds () 2.23 economics () 2.24 expand_limits () 2.25 facet_grid () 2.26 facet_wrap () 2.27 faithfuld () 2.28 fortify () 2.29 geom_abline () 2.30 geom_bar () 2.31 geom_bin2d () 2.32 geom_blank () 2.33 geom_boxplot () 2.34 geom_contour () 2.35 geom_count () 2.36 geom_crossbar () 2.37 geom_density () 2.38 geom_density_2d () 2.39 geom_dotplot () 2.40 geom_errorbarh () 2.41 geom_freqpoly () 2.42 geom_hex () 2.43 geom_jitter () 2.44 geom_label () 2.45 geom_map () 2.46 geom_path () 2.47 geom_point () 2.48 geom_polygon () 2.49 geom_qq () 2.50 geom_quantile () 2.51 geom_raster () 2.52 geom_ribbon () 2.53 geom_rug () 2.54 geom_segment () 2.55 geom_smooth () 2.56 geom_spoke () 2.57 geom_violin () 2.58 ggplot () 2.59 ggproto () 2.60 ggsave () 2.61 ggtheme () 2.62 guides () 2.63 guide_colourbar () 2.64 guide_legend () 2.65 hmisc () 2.66 labeller () 2.67 labellers () 2.68 label_bquote () 2.69 labs () 2.70 lims () 2.71 luv_colours () 2.72 margin () 2.73 mean_se () 2.74 midwest () 2.75 mpg () 2.76 msleep () 2.77 position_dodge () 2.78 position_identity () 2.79 position_jitter () 2.80 position_jitterdodge () 2.81 position_nudge () 2.82 position_stack () 2.83 presidential () 2.84 print.ggplot () 2.85 print.ggproto () 2.86 qplot () 2.87 resolution () 2.88 scale_alpha () 2.89 scale_colour_brewer () 2.90 scale_colour_gradient () 2.91 scale_colour_grey () 2.92 scale_colour_hue () 2.93 scale_continuous () 2.94 scale_date () 2.95 scale_identity () 2.96 scale_linetype () 2.97 scale_manual () 2.98 scale_shape () 2.99 scale_size () 2.100 scale_x_discrete () 2.101 seals () 2.102 sec_axis () 2.103 stat_ecdf () 2.104 stat_ellipse () 2.105 stat_function () 2.106 stat_identity () 2.107 stat_summary_2d () 2.108 stat_summary_bin () 2.109 stat_unique () 2.110 theme () 2.111 theme_get () 2.112 txhousing () 2.113 ggiraph", " 2 ggplot2 2.1 +.gg () 2.2 aes () 2.3 aes_ () 2.4 aes_colour_fill_alpha () 2.5 aes_group_order () 2.6 aes_linetype_size_shape () 2.7 aes_position () 2.8 annotate () 2.9 annotation_custom () 2.10 annotation_logticks () 2.11 annotation_map () 2.12 annotation_raster () 2.13 autoplot () 2.14 borders () 2.15 coord_cartesian () 2.16 coord_fixed () 2.17 coord_flip () 2.18 coord_map () 2.19 coord_polar () 2.20 coord_trans () 2.21 cut_interval () 2.22 diamonds () 2.23 economics () 2.24 expand_limits () 2.25 facet_grid () 2.26 facet_wrap () 2.27 faithfuld () 2.28 fortify () 2.29 geom_abline () 2.30 geom_bar () 2.31 geom_bin2d () 2.32 geom_blank () 2.33 geom_boxplot () 2.34 geom_contour () 2.35 geom_count () 2.36 geom_crossbar () 2.37 geom_density () 2.38 geom_density_2d () 2.39 geom_dotplot () 2.40 geom_errorbarh () 2.41 geom_freqpoly () 2.42 geom_hex () 2.43 geom_jitter () 2.44 geom_label () 2.45 geom_map () 2.46 geom_path () 2.47 geom_point () 2.48 geom_polygon () 2.49 geom_qq () 2.50 geom_quantile () 2.51 geom_raster () 2.52 geom_ribbon () 2.53 geom_rug () 2.54 geom_segment () 2.55 geom_smooth () 2.56 geom_spoke () 2.57 geom_violin () 2.58 ggplot () 2.59 ggproto () 2.60 ggsave () 2.61 ggtheme () 2.62 guides () 2.63 guide_colourbar () 2.64 guide_legend () 2.65 hmisc () 2.66 labeller () 2.67 labellers () 2.68 label_bquote () 2.69 labs () 2.70 lims () 2.71 luv_colours () 2.72 margin () 2.73 mean_se () 2.74 midwest () 2.75 mpg () 2.76 msleep () 2.77 position_dodge () 2.78 position_identity () 2.79 position_jitter () 2.80 position_jitterdodge () 2.81 position_nudge () 2.82 position_stack () 2.83 presidential () 2.84 print.ggplot () 2.85 print.ggproto () 2.86 qplot () 2.87 resolution () 2.88 scale_alpha () 2.89 scale_colour_brewer () 2.90 scale_colour_gradient () 2.91 scale_colour_grey () 2.92 scale_colour_hue () 2.93 scale_continuous () 2.94 scale_date () 2.95 scale_identity () 2.96 scale_linetype () 2.97 scale_manual () This recipe is available including rendered plots as an Rpubs here: http://rpubs.com/hmgeiger/384663 This Github contains just the code for now, not including rendered plots. Read in a CSV file with survey data about Thanksgiving. More info available here: https://github.com/fivethirtyeight/data/tree/master/thanksgiving-2015 csv_link &lt;- &quot;https://raw.githubusercontent.com/fivethirtyeight/data/master/thanksgiving-2015/thanksgiving-2015-poll-data.csv&quot; thanksgiving &lt;- read.csv(csv_link,header=TRUE,stringsAsFactors=FALSE,check.names=FALSE) Filter only for individuals that celebrate Thanksgiving, after cleaning up some column names. colnames(thanksgiving)[2] &lt;- &quot;Celebrates_Thanksgiving&quot; colnames(thanksgiving)[c(25,38,50)] &lt;- c(&quot;Which of these side dishes aretypically served at your Thanksgiving dinner? Please select all that apply. - Other (please specify again)&quot;, &quot;Which type of pie is typically served at your Thanksgiving dinner? Please select all that apply. - Other (please specify again)&quot;, &quot;Which of these desserts do you typically have at Thanksgiving dinner? Please select all that apply. - Other (please specify again)&quot;) thanksgiving &lt;- thanksgiving %&gt;% filter(Celebrates_Thanksgiving == &quot;Yes&quot;) Select columns corresponding to side dishes, minus “Other”. Then, count number of people who selected each side. side_dish_columns &lt;- grep(&#39;Which of these side dishes aretypically served at your Thanksgiving dinner?&#39;,colnames(thanksgiving),value=TRUE) side_dish_columns &lt;- side_dish_columns[grep(&#39;Other&#39;,side_dish_columns,invert=TRUE)] side_dish_frequency &lt;- data.frame(Side = rep(NA,times=length(side_dish_columns)), Frequency = rep(NA,times=length(side_dish_columns))) for(i in 1:length(side_dish_columns)) { side_name &lt;- str_replace_all(side_dish_columns[i], pattern=&#39;Which of these side dishes aretypically served at your Thanksgiving dinner\\\\? Please select all that apply\\\\. - &#39;, replace=&#39;&#39;) side_dish_frequency[i,] &lt;- c(side_name,length(which(thanksgiving[,side_dish_columns[i]] != &quot;&quot;))) } side_dish_frequency$Frequency &lt;- as.numeric(side_dish_frequency$Frequency) Make a barplot of the frequency of different sides, minus “Other”. ggplot(side_dish_frequency,aes(Side,Frequency)) + geom_bar(stat=&quot;identity&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) Now use scale_fill_manual to color each bar by a color appropriate to the food. Use colors here as a guide: http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf Put in colors based on order sides appear in side_dish_frequency. Let’s color fruit salad as red, since may have watermelon, strawberry, etc. ggplot(side_dish_frequency,aes(Side,Frequency,fill=Side)) + geom_bar(stat=&quot;identity&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_fill_manual(values = c(&quot;darkgreen&quot;,&quot;darkorange&quot;,&quot;floralwhite&quot;,&quot;gold&quot;,&quot;gold&quot;,&quot;firebrick1&quot;,&quot;darkgreen&quot;,&quot;gold&quot;,&quot;floralwhite&quot;,&quot;floralwhite&quot;,&quot;darkorange&quot;,&quot;darkgreen&quot;,&quot;darkorange&quot;)) Sort by frequency, then adjust the order of the color vector accordingly. color_per_side &lt;- c(&quot;darkgreen&quot;,&quot;darkorange&quot;,&quot;floralwhite&quot;,&quot;gold&quot;,&quot;gold&quot;,&quot;firebrick1&quot;,&quot;darkgreen&quot;,&quot;gold&quot;,&quot;floralwhite&quot;,&quot;floralwhite&quot;,&quot;darkorange&quot;,&quot;darkgreen&quot;,&quot;darkorange&quot;) color_per_side &lt;- color_per_side[order(side_dish_frequency$Frequency)] side_dish_frequency$Side &lt;- factor(side_dish_frequency$Side, levels=side_dish_frequency$Side[order(side_dish_frequency$Frequency)]) ggplot(side_dish_frequency, aes(Side,Frequency,fill=Side)) + geom_bar(stat=&quot;identity&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_fill_manual(values = color_per_side) We find that the two most popular Thanksgiving sides are both white. What if we use shape_colour_manual instead, and specify color by side instead of fill by side? ggplot(side_dish_frequency, aes(Side,Frequency,colour=Side)) + geom_bar(stat=&quot;identity&quot;,fill=&quot;lightgrey&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_colour_manual(values = color_per_side) Now the color of the border of the bars will change based on the colors we have specified. Using “colour” instead of “fill” probably isn’t what we want for a barplot. But it might be useful for other types of plots (like scatterplots with a hollow dot for the points). 2.98 scale_shape () 2.99 scale_size () 2.100 scale_x_discrete () 2.101 seals () 2.102 sec_axis () 2.103 stat_ecdf () 2.104 stat_ellipse () 2.105 stat_function () 2.106 stat_identity () 2.107 stat_summary_2d () 2.108 stat_summary_bin () 2.109 stat_unique () 2.110 theme () 2.111 theme_get () 2.112 txhousing () 2.113 ggiraph There is a complement to the ggplot2 function - ggiraph. Ggiraph allows the user to turn their normal ggplot graphs into interactive graphics. Some usage of the ggiraph functions are: geom_bar_interactive geom_boxplot_interactive geom_histogram_interactive geom_line_interactive geom_map_interactive geom_path_interactive geom_point_interactive geom_polygon_interactive geom_rect_interactive geom_segment_interactive geom_text_interactive geom_tile_interactive The ggiraph package lets you add more aesthetics to your ggplot graph. tooltip: column of dataset that contains tooltips to be displayed when mouse is over elements. data_id: column of dataset that contains id to be associated with elements The ggiraph function is called using library(ggiraph). Tooltips Tooltips can be created using the following example: # Need to debug and get rid of eval=FALSE above once working library(tidyverse) library(ggiraph) library(fueleconomy) # Need to debug and get rid of eval=FALSE above once working ggexample &lt;- ggplot(vehicles, aes(factor(vehicles$year), vehicles$hwy)) + geom_boxplot_interactive(aes(tooltip = year)) ggiraph(code = print(ggexample)) When the users mouse hovers over an item, the tooltip will be displayed - in this case “Year”. Hover effects can be created using the following example: # Need to debug and get rid of eval=FALSE above once working ggexample &lt;- ggplot(vehicles, aes(factor(vehicles$year), vehicles$hwy, color = hwy)) + geom_boxplot_interactive(aes(tooltip = year, data_id = year)) ggiraph(code = print(ggexample)) As you can see in the example above, the boxs change color on when the users mouse hovers over the item. More information can be found here: http://rpubs.com/nschettini/386363 "],
["dplyr.html", "3 dplyr 3.1 select() 3.2 rename() 3.3 filter() 3.4 arrange() 3.5 mutate() and transmute() 3.6 summarise() 3.7 sample_n() and sample_frac() 3.8 sparklyr", " 3 dplyr dplyr provides a grammar of data manipulation, providing a consistent set of verbs that solve the most common data manipulation challenges. 3.1 select() The select function provides options for selecting only certain columns of data to work with. library(tidyverse) library(knitr) library(kableExtra) alcohol.data &lt;- read_csv(&#39;https://raw.githubusercontent.com/fivethirtyeight/data/master/alcohol-consumption/drinks.csv&#39;) alcohol.data %&gt;% head() %&gt;% kable() country beer_servings spirit_servings wine_servings total_litres_of_pure_alcohol Afghanistan 0 0 0 0.0 Albania 89 132 54 4.9 Algeria 25 0 14 0.7 Andorra 245 138 312 12.4 Angola 217 57 45 5.9 Antigua &amp; Barbuda 102 128 45 4.9 At it’s most basic, select allows for the manual selection of columns alcohol.data %&gt;% select(country, total_litres_of_pure_alcohol) %&gt;% head() %&gt;% kable() country total_litres_of_pure_alcohol Afghanistan 0.0 Albania 4.9 Algeria 0.7 Andorra 12.4 Angola 5.9 Antigua &amp; Barbuda 4.9 alcohol.data %&gt;% select(c(1, 3)) %&gt;% head() %&gt;% kable() country spirit_servings Afghanistan 0 Albania 132 Algeria 0 Andorra 138 Angola 57 Antigua &amp; Barbuda 128 alcohol.data %&gt;% select(1:4) %&gt;% head() %&gt;% kable() country beer_servings spirit_servings wine_servings Afghanistan 0 0 0 Albania 89 132 54 Algeria 25 0 14 Andorra 245 138 312 Angola 217 57 45 Antigua &amp; Barbuda 102 128 45 There are a number of additional functions that can be used to select columns based on specific criteria. These include: starts_with() which selects all columns that begin with the given text ends_with() which selects all columns that end with the given text contains() which selects all columns that contain the given text anywhere matches() which selects all columns that match the given regular expression. See regular expressions for more details. num_range(&quot;x&quot;, 1:5) which selects the variables named x01, x02, x03, x04 and x05 one_of(x) which selects every name that appears in x, which should be a character vector. Finally, a dash (-) may be added to the beginning of any of these functions to select all columns that do NOT match. alcohol.data %&gt;% select(-ends_with(&#39;servings&#39;)) %&gt;% head() %&gt;% kable() country total_litres_of_pure_alcohol Afghanistan 0.0 Albania 4.9 Algeria 0.7 Andorra 12.4 Angola 5.9 Antigua &amp; Barbuda 4.9 The select function can also be used to rearrange the columns in a data frame. alcohol.data %&gt;% select(1, 5, 2:4) %&gt;% head() %&gt;% kable() country total_litres_of_pure_alcohol beer_servings spirit_servings wine_servings Afghanistan 0.0 0 0 0 Albania 4.9 89 132 54 Algeria 0.7 25 0 14 Andorra 12.4 245 138 312 Angola 5.9 217 57 45 Antigua &amp; Barbuda 4.9 102 128 45 A special function everything() will select all remaining columns in order. This is best used when you wish to move a single column to a new position but do not care to rearrange the remaining columns. alcohol.data %&gt;% select(1, 5, everything()) %&gt;% head() %&gt;% kable() country total_litres_of_pure_alcohol beer_servings spirit_servings wine_servings Afghanistan 0.0 0 0 0 Albania 4.9 89 132 54 Algeria 0.7 25 0 14 Andorra 12.4 245 138 312 Angola 5.9 217 57 45 Antigua &amp; Barbuda 4.9 102 128 45 Select also has the ability to rename columns, however, it will drop all columns not mentioned. In order to rename columns but to keep all columns (regardless of whether their names have been changed) it is best to use rename(). See rename(). alcohol.data %&gt;% select(location=country, everything()) %&gt;% head() %&gt;% kable() location beer_servings spirit_servings wine_servings total_litres_of_pure_alcohol Afghanistan 0 0 0 0.0 Albania 89 132 54 4.9 Algeria 25 0 14 0.7 Andorra 245 138 312 12.4 Angola 217 57 45 5.9 Antigua &amp; Barbuda 102 128 45 4.9 3.2 rename() The rename function is used to alter the names of columns. Any columns not specified will not be changed. If you wish to drop unnamed columns at the same time, use select() See select(). alcohol.data %&gt;% rename(beer=beer_servings, spirit=spirit_servings, wine=wine_servings) %&gt;% head() %&gt;% kable() country beer spirit wine total_litres_of_pure_alcohol Afghanistan 0 0 0 0.0 Albania 89 132 54 4.9 Algeria 25 0 14 0.7 Andorra 245 138 312 12.4 Angola 217 57 45 5.9 Antigua &amp; Barbuda 102 128 45 4.9 3.3 filter() The filter function allows a user to subset a data frame based on the values in a given column. avengers.data &lt;- read_csv(&#39;https://raw.githubusercontent.com/fivethirtyeight/data/master/avengers/avengers.csv&#39;) %&gt;% select(2:6) avengers.data %&gt;% head() %&gt;% kable() Name/Alias Appearances Current? Gender Probationary Introl Henry Jonathan “Hank” Pym 1269 YES MALE NA Janet van Dyne 1165 YES FEMALE NA Anthony Edward “Tony” Stark 3068 YES MALE NA Robert Bruce Banner 2089 YES MALE NA Thor Odinson 2402 YES MALE NA Richard Milhouse Jones 612 YES MALE NA Perhaps the user would like to work only with the female avengers. avengers.data %&gt;% filter(Gender == &#39;FEMALE&#39;) %&gt;% head() %&gt;% kable() Name/Alias Appearances Current? Gender Probationary Introl Janet van Dyne 1165 YES FEMALE NA Wanda Maximoff 1214 YES FEMALE NA Natalia Alianovna Romanova 1112 YES FEMALE NA Brandt 160 NO FEMALE NA Heather Douglas 332 NO FEMALE Jul-75 Patsy Walker 557 NO FEMALE Nov-75 Perhaps the user would like to work only with female avengers with more than 500 appearances. avengers.data %&gt;% filter(Gender == &#39;FEMALE&#39; &amp; Appearances &gt; 500) %&gt;% head() %&gt;% kable() Name/Alias Appearances Current? Gender Probationary Introl Janet van Dyne 1165 YES FEMALE NA Wanda Maximoff 1214 YES FEMALE NA Natalia Alianovna Romanova 1112 YES FEMALE NA Patsy Walker 557 NO FEMALE Nov-75 Carol Susan Jane Danvers 935 YES FEMALE NA Jennifer Walters 933 YES FEMALE NA There are numerous comparison options that can be used with filter. These include: ==, &gt;, &gt;=, &lt;, &lt;=, != The use of a single ampersand &amp; is used to indicate ‘and’ while a single pipe | is used to indicate ‘or’. The exclamation point ! is used to indicate ‘nor’ (see next example) and xor() is the exclusive or. Filtering can also be based on whether an element is NA. This data set does not have any NAs, but rather has empty strings in cases where the variable does not apply. To demonstrate the technique of filtering out NAs, let’s convert these empty strings to NAs. Then, use the filter function to select cases where the variable is non-NA. avengers.data_incl_NAs &lt;- data.frame(avengers.data,check.names=FALSE) var &lt;- &quot;Probationary Introl&quot; avengers.data_incl_NAs[,var] &lt;- plyr::mapvalues(avengers.data_incl_NAs[,var], from = &quot;&quot;,to=NA) ## The following `from` values were not present in `x`: avengers.data_incl_NAs %&gt;% filter(!is.na(`Probationary Introl`)) %&gt;% kable() Name/Alias Appearances Current? Gender Probationary Introl Henry P. McCoy 1886 NO MALE Jul-75 Heather Douglas 332 NO FEMALE Jul-75 Patsy Walker 557 NO FEMALE Nov-75 Robert L. Frank Sr. 106 NO MALE Apr-77 Simon Williams 692 YES MALE Apr-77 Jocasta 141 YES FEMALE Jul-80 Monica Rambeau 348 YES FEMALE Jan-83 Eros 206 NO MALE Jun-83 James R. Rhodes 533 NO MALE May-84 Barbara Barton (nee Morse) 374 NO FEMALE Jun-84 Marc Spector 402 NO MALE Sep-87 Scott Edward Harris Lang 217 NO MALE Jan-87 Elvin Haliday 158 NO MALE Feb-91 William Baker 355 NO MALE Feb-91 Crystal Amaquelin Maximoff 517 NO FEMALE Aug-91 Between can be used to filter between a range of values. avengers.data %&gt;% filter(between(Appearances, 500, 1000)) %&gt;% head() %&gt;% kable() Name/Alias Appearances Current? Gender Probationary Introl Richard Milhouse Jones 612 YES MALE NA Pietro Maximoff 769 YES MALE NA Heracles 741 YES MALE NA T’Challa 780 NO MALE NA Patsy Walker 557 NO FEMALE Nov-75 Simon Williams 692 YES MALE Apr-77 Finally, near can be used to select a range of values within a certain range of a central value. avengers.data %&gt;% filter(near(Appearances, 612, tol=20)) %&gt;% head() %&gt;% kable() Name/Alias Appearances Current? Gender Probationary Introl Richard Milhouse Jones 612 YES MALE NA Daniel Thomas Rand K’ai 629 NO MALE NA Of course, all of these can be combined with ‘and’ &amp; and ‘or’ | logical operators. There are three related functions filter_if(), filter_all(), and filter_at(). See scoped operations. For a last example, let’s combine the and operator with the or operator to choose results meeting two mutually exclusive criteria, each based on two different conditions. high_appearance_females &lt;- avengers.data %&gt;% filter(Gender == &quot;FEMALE&quot; &amp; Appearances &gt; 500) low_appearance_males &lt;- avengers.data %&gt;% filter(Gender == &quot;MALE&quot; &amp; Appearances &lt; 200) high_appearance_females_or_low_appearance_males &lt;- avengers.data %&gt;% filter((Gender == &quot;FEMALE&quot; &amp; Appearances &gt; 500) | (Gender == &quot;MALE&quot; &amp; Appearances &lt; 200)) nrow(high_appearance_females) ## [1] 10 nrow(low_appearance_males) ## [1] 65 nrow(high_appearance_females_or_low_appearance_males) ## [1] 75 There are 10 high appearance females and 65 low appearance males. Thus, the fact that we get 75 results for the query using OR operator makes sense, as the criteria we looked for using the OR operator are mutually exclusive. 3.4 arrange() arrange changes the natural column order of the data frame. It takes data frame name and the column name(s) as input and re arranges the columns based on input. 3.5 mutate() and transmute() The mutate function creates new columns which can be added to a copy of the dataset. You can also add new columns to your existing dataset by overwriting it like this: alcohol.data &lt;- mutate(alcohol.data, total_servings = beer_servings + spirit_servings + wine_servings) You can use any mathematical operator (+, -, *, /) as well as functions like: log() lead(), lag() dense_rank(), min_rank(), percent_rank(), row_number(), cume_dist(), ntile() cumsum(), cummean(), cummin(), cummax(), cumany(), cumall() na_if(), coalesce() if_else(), recode(), case_when() # Rank into 5 &quot;buckets&quot; by displacement mtcars &lt;- mutate(mtcars, rank = ntile(disp, 5)) Transmute does the same thing as mutate, but drops all the other columns not specified in your function arguments. transmute(alcohol.data, country, total_servings = beer_servings + spirit_servings + wine_servings) ## # A tibble: 193 x 2 ## country total_servings ## &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 0 ## 2 Albania 275 ## 3 Algeria 39 ## 4 Andorra 695 ## 5 Angola 319 ## 6 Antigua &amp; Barbuda 275 ## 7 Argentina 439 ## 8 Armenia 211 ## 9 Australia 545 ## 10 Austria 545 ## # ... with 183 more rows 3.6 summarise() The summarise function returns a table of summary statistics that you specify by running functions on your data. You name each statistic and then specify what function to use and separate additional statistics with commas like this: summarise(mtcars, avg_disp = mean(disp), max_disp = max(disp), min_disp = min(disp), median_disp = median(disp)) ## avg_disp max_disp min_disp median_disp ## 1 230.7219 472 71.1 196.3 In addition to all the usual summary statistic functions in R, summarise comes with some additional functions that you can use: first() - returns the first value last - returns the last value nth - returns the nth value n - returns the number of rows n_distinct - returns the number of unique values summarise(mtcars, first = first(disp), last = last(disp), fifth = nth(disp, 5), n = n(), unique = n_distinct(disp)) ## first last fifth n unique ## 1 160 121 360 32 27 3.7 sample_n() and sample_frac() sample_n and sample_frac return random samples from your data. sample_n will select the number of rows you specify in the second argument at random. sample_frac returns a random sample fraction of rows. You specify the fraction of rows you want returned in your second function argument with a decimal number from 0 to 1. Both functions can be set to sample with or without replacement using the replace = TRUE/FALSE argument. sample_n(mtcars, 5, replace = TRUE) ## mpg cyl disp hp drat wt qsec vs am gear carb rank ## 21 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 1 ## 17 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 5 ## 15 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 5 ## 11 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 3 ## 23 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 4 sample_frac(mtcars, 0.25, replace = FALSE) ## mpg cyl disp hp drat wt qsec vs am gear carb rank ## 6 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 3 ## 14 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 4 ## 4 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 3 ## 26 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 1 ## 1 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 2 ## 17 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 5 ## 20 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 1 ## 32 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 2 3.8 sparklyr Connect to Spark from R. The sparklyr package provides a complete dplyr backend. Filter and aggregate Spark datasets then bring them into R for analysis and visualization. 3.8.1 Installation of sparklyr and Spark on local machine If you want to run the code chunks below to install and run the sparklyr demo, remove the “eval=FALSE” argument from the chunk settings. Also note: You need to have the latest Java SE Development Kit installed to run this code. install.packages(&quot;sparklyr&quot;) In order to get the latest sparklyr devtools::install_github(&quot;rstudio/sparklyr&quot;) 3.8.1.1 Install a local version of Spark for development purposes library(sparklyr) spark_install(version = &#39;2.2.0&#39;) 3.8.1.2 Connecting to Spark 3.8.1.3 Set up the Spark Home directory You need to set the SPARK_HOME to the path where you downloaded spark from previous line. For Mac OS it will be something like: “/Users/USERNAME/spark/spark-2.2.0-bin-hadoop2.7”. For Windows it will be similar to the path in the code below. Sys.setenv(SPARK_HOME=&quot;C:\\\\Users\\\\USERNAME\\\\AppData\\\\Local\\\\spark\\\\spark-2.2.0-bin-hadoop2.7&quot;) sc &lt;- spark_connect(master = &quot;local&quot;) 3.8.1.4 Using dplyr and copy datasets from R into the local Spark Cluster library(dplyr) #install.packages(&quot;nycflights13&quot;) iris_tbl &lt;- copy_to(sc, iris) flights_tbl &lt;- copy_to(sc, nycflights13::flights, &quot;flights&quot;) src_tbls(sc) 3.8.2 Using filter() flights_tbl %&gt;% filter(dep_delay == 2) 3.8.3 group_by(), summarise() and collect() delay &lt;- flights_tbl %&gt;% group_by(tailnum) %&gt;% summarise(count = n(), dist = mean(distance), delay = mean(arr_delay)) %&gt;% filter(count &gt; 20, dist &lt; 2000, !is.na(delay)) %&gt;% collect # plot delays library(ggplot2) ggplot(delay, aes(dist, delay)) + geom_point(aes(size = count), alpha = 1/2) + geom_smooth() + scale_size_area(max_size = 2) "],
["tidyr.html", "4 tidyr 4.1 complete () 4.2 drop_na () 4.3 expand () 4.4 extract () 4.5 fill () 4.6 full_seq () 4.7 gather () 4.8 nest () 4.9 replace_na () 4.10 separate () 4.11 separate_rows () 4.12 smiths () 4.13 spread () 4.14 uncount () 4.15 unite () 4.16 unnest () 4.17 who ()", " 4 tidyr 4.1 complete () Complete a data frame with missing combinations of data. Description: Turns implicit missing values into explicit missing values. This is a wrapper around expand(), dplyr::left_join() and replace_na() that’s useful for completing missing combinations of data. Usage: complete(data, ..., fill = list()) Example: library(dplyr, warn.conflicts = FALSE) df &lt;- tibble( group = c(1:2, 1), item_id = c(1:2, 2), item_name = c(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;), value1 = 1:3, value2 = 4:6 ) df %&gt;% complete(group, nesting(item_id, item_name)) # You can also choose to fill in missing values df %&gt;% complete(group, nesting(item_id, item_name), fill = list(value1 = 0)) 4.2 drop_na () Drop rows containing missing values Description: Drop rows containing missing values Usage: drop_na(data, ...) Example: library(dplyr) df &lt;- tibble(x = c(1, 2, NA), y = c(“a”, NA, “b”)) df %&gt;% drop_na() df %&gt;% drop_na(x) 4.3 expand () Expand data frame to include all combinations of values Description: expand() is often useful in conjunction with left_join if you want to convert implicit missing values to explicit missing values. Or you can use it in conjunction with anti_join() to figure out which combinations are missing. Usage: expand(data, ...) Example: library(dplyr) # All possible combinations of vs &amp; cyl, even those that aren&#39;t # present in the data expand(mtcars, vs, cyl) 4.4 extract () Extract one column into multiple columns. Description: Given a regular expression with capturing groups, extract() turns each group into a new column. If the groups don’t match, or the input is NA, the output will be NA. Usage: extract(data, col, into, regex = &quot;([[:alnum:]]+)&quot;, remove = TRUE, convert = FALSE, ...) Example: library(dplyr) df &lt;- data.frame(x = c(NA, &quot;a-b&quot;, &quot;a-d&quot;, &quot;b-c&quot;, &quot;d-e&quot;)) df %&gt;% extract(x, &quot;A&quot;) df %&gt;% extract(x, c(&quot;A&quot;, &quot;B&quot;), &quot;([[:alnum:]]+)-([[:alnum:]]+)&quot;) 4.5 fill () Fill in missing values. Description: Fills missing values in using the previous entry. This is useful in the common output format where values are not repeated, they’re recorded each time they change. Usage: fill(data, ..., .direction = c(&quot;down&quot;, &quot;up&quot;)) Example: df &lt;- data.frame(Month = 1:12, Year = c(2000, rep(NA, 11))) df %&gt;% fill(Year) 4.6 full_seq () 4.7 gather () Gather columns into key-value pairs. Description: Gather takes multiple columns and collapses into key-value pairs, duplicating all other columns as needed. You use gather() when you notice that you have columns that are not variables. Usage: gather(data, key = &quot;key&quot;, value = &quot;value&quot;, ..., na.rm = FALSE, convert = FALSE, factor_key = FALSE) Example: library(dplyr) # From http://stackoverflow.com/questions/1181060 stocks &lt;- tibble( time = as.Date(&#39;2009-01-01&#39;) + 0:9, X = rnorm(10, 0, 1), Y = rnorm(10, 0, 2), Z = rnorm(10, 0, 4)) gather(stocks, stock, price, -time) stocks %&gt;% gather(stock, price, -time) 4.8 nest () Nest repeated values in a list-variable. Description: There are many possible ways one could choose to nest columns inside a data frame. nest() creates a list of data frames containing all the nested variables: this seems to be the most useful form in practice. Usage: nest(data, ..., .key = &quot;data&quot;) Example: library(dplyr) as_tibble(iris) %&gt;% nest(-Species) as_tibble(chickwts) %&gt;% nest(weight) if (require(&quot;gapminder&quot;)) { gapminder %&gt;% group_by(country, continent) %&gt;% nest() gapminder %&gt;% nest(-country, -continent) } 4.9 replace_na () Replace missing values Description: Replace missing values Usage: replace_na(data, replace, ...) Example: library(dplyr) df &lt;- tibble(x = c(1, 2, NA), y = c(&quot;a&quot;, NA, &quot;b&quot;), z = list(1:5, NULL, 10:20)) df %&gt;% replace_na(list(x = 0, y = &quot;unknown&quot;)) # NULL are the list-col equivalent of NAs df %&gt;% replace_na(list(z = list(5))) df$x %&gt;% replace_na(0) df$y %&gt;% replace_na(&quot;unknown&quot;) 4.10 separate () Separate one column into multiple columns. Description: Given either regular expression or a vector of character positions, separate() turns a single char- acter column into multiple columns. Usage: separate(data, col, into, sep = &quot;[^[:alnum:]]+&quot;, remove = TRUE, convert = FALSE, extra = &quot;warn&quot;, fill = &quot;warn&quot;, ...) Example: library(dplyr) df &lt;- data.frame(x = c(NA, &quot;a.b&quot;, &quot;a.d&quot;, &quot;b.c&quot;)) df %&gt;% separate(x, c(&quot;A&quot;, &quot;B&quot;)) # If every row doesn&#39;t split into the same number of pieces, use # the extra and file arguments to control what happens df &lt;- data.frame(x = c(&quot;a&quot;, &quot;a b&quot;, &quot;a b c&quot;, NA)) df %&gt;% separate(x, c(&quot;a&quot;, &quot;b&quot;)) # The same behaviour but no warnings df %&gt;% separate(x, c(&quot;a&quot;, &quot;b&quot;), extra = &quot;drop&quot;, fill = &quot;right&quot;) # Another option: df %&gt;% separate(x, c(&quot;a&quot;, &quot;b&quot;), extra = &quot;merge&quot;, fill = &quot;left&quot;) # If only want to split specified number of times use extra = &quot;merge&quot; df &lt;- data.frame(x = c(&quot;x: 123&quot;, &quot;y: error: 7&quot;)) df %&gt;% separate(x, c(&quot;key&quot;, &quot;value&quot;), &quot;: &quot;, extra = &quot;merge&quot;) 4.11 separate_rows () 4.12 smiths () 4.13 spread () Take a tidy key-value pairs and spread them across multiple columns. Description: The antithesis of gather, spread() unstacks or unpivots tables by spreading rows into columns. Usage: spread(data, key, value, fill = NA, convert = FALSE, drop = TRUE, sep = NULL) Example: library(tidyr) library(kableExtra) alcohol.data &lt;- read_csv(&#39;https://raw.githubusercontent.com/fivethirtyeight/data/master/alcohol-consumption/drinks.csv&#39;) ## Parsed with column specification: ## cols( ## country = col_character(), ## beer_servings = col_integer(), ## spirit_servings = col_integer(), ## wine_servings = col_integer(), ## total_litres_of_pure_alcohol = col_double() ## ) alcohol.data %&gt;% head() %&gt;% kable() country beer_servings spirit_servings wine_servings total_litres_of_pure_alcohol Afghanistan 0 0 0 0.0 Albania 89 132 54 4.9 Algeria 25 0 14 0.7 Andorra 245 138 312 12.4 Angola 217 57 45 5.9 Antigua &amp; Barbuda 102 128 45 4.9 # While gather() &quot;pivots&quot; the data table so that each observation forms a row... alc.gather &lt;- alcohol.data %&gt;% gather(&quot;type&quot;, &quot;amount&quot;, 2:5) alc.gather %&gt;% head() %&gt;% kable() country type amount Afghanistan beer_servings 0 Albania beer_servings 89 Algeria beer_servings 25 Andorra beer_servings 245 Angola beer_servings 217 Antigua &amp; Barbuda beer_servings 102 # ...spread() performs the opposite operation, widening the data table. alc.spread &lt;- alc.gather %&gt;% spread(type, amount) alc.spread %&gt;% head() %&gt;% kable() country beer_servings spirit_servings total_litres_of_pure_alcohol wine_servings Afghanistan 0 0 0.0 0 Albania 89 132 4.9 54 Algeria 25 0 0.7 14 Andorra 245 138 12.4 312 Angola 217 57 5.9 45 Antigua &amp; Barbuda 102 128 4.9 45 ## table1 () 4.14 uncount () 4.15 unite () 4.16 unnest () 4.17 who () "],
["readr.html", "5 readr 5.1 read_csv() 5.2 cols () 5.3 cols_condense () 5.4 col_skip () 5.5 count_fields () 5.6 date_names () 5.7 format_delim () 5.8 guess_encoding () 5.9 locale () 5.10 parse_atomic () 5.11 parse_datetime (), parse_date() and parse_time() 5.12 parse_factor () 5.13 parse_logical(), parse_number(), parse_double() and parse_integer() 5.14 parse_character() 5.15 parse_guess () 5.16 problems () 5.17 read_delim () 5.18 read_file () 5.19 read_fwf () 5.20 read_lines () 5.21 read_log () 5.22 read_table () 5.23 spec_delim () 5.24 type_convert () 5.25 write_delim ()", " 5 readr library(tidyverse) library(hms) 5.1 read_csv() read_csv() - Reads comma-delimited files read_csv2() - Reads semicolon-separated files read_tsv() - Reads tab-delimited files read_delim() - Reads in files with any delimiter Read file will print out a column specification that gives the name and type of each column: data &lt;- read_csv(&quot;https://raw.githubusercontent.com/cunydata607/r-bookdown/master/Book%20Project%20Files/datasets/example.csv&quot;) ## Parsed with column specification: ## cols( ## `Welcome to r bookdown!` = col_character() ## ) read_csv() uses the first line of the data for the column names, the following examples will show how to tweak this behavior: Using skip = n (n is the number of lines to skip) read_csv(&quot;This the first line This is the second line a,b,c 1,2,3&quot;, skip = 2) ## # A tibble: 1 x 3 ## a b c ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 2 3 Using comment = “#” to skip all lines that starts with “#” read_csv(&quot;# This is a comment line a,b,c 1,2,3&quot;, comment = &quot;#&quot;) ## # A tibble: 1 x 3 ## a b c ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 2 3 If there’s no column names, using col_names = FALSE read_csv(&quot;1,2,3 4,5,6&quot;, col_names = FALSE) ## # A tibble: 2 x 3 ## X1 X2 X3 ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 2 3 ## 2 4 5 6 If there’s column names read_csv(&quot;1,2,3 4,5,6&quot;, col_names = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## # A tibble: 2 x 3 ## a b c ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 2 3 ## 2 4 5 6 5.2 cols () 5.3 cols_condense () 5.4 col_skip () 5.5 count_fields () 5.6 date_names () 5.7 format_delim () 5.8 guess_encoding () To find the types of encoding: guess_encoding(charToRaw(&quot;Data Analytics&quot;)) ## # A tibble: 1 x 2 ## encoding confidence ## &lt;chr&gt; &lt;dbl&gt; ## 1 ASCII 1. 5.9 locale () The goal of readr’s locales is to encapsulate common options that vary between languages and localities. This includes: - The names of months and days, used when parsing dates. - The default time zone, used when parsing datetimes. - The character encoding, used when reading non-ASCII strings. - Default date format, used when guessing column types. - The decimal and grouping marks, used when reading numbers. 5.10 parse_atomic () 5.11 parse_datetime (), parse_date() and parse_time() Allow to parse varoious date and time specifications. str(parse_date(c(&quot;2018-05-01&quot;, &quot;2018-04-30&quot;))) ## Date[1:2], format: &quot;2018-05-01&quot; &quot;2018-04-30&quot; parse_time(c(&quot;6:43 pm&quot;)) ## 18:43:00 5.12 parse_factor () Creates factors, the data structure that R uses to represent categorical variables with fixed and known values. parse_factor(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), levels = c(&quot;a&quot;, &quot;b&quot;)) ## [1] a b &lt;NA&gt; ## attr(,&quot;problems&quot;) ## # A tibble: 1 x 4 ## row col expected actual ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 3 NA value in level set c ## Levels: a b 5.13 parse_logical(), parse_number(), parse_double() and parse_integer() Parse logicals, numbers, doubles and integers respectively. str(parse_logical(c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;NA&quot;))) ## logi [1:3] TRUE FALSE NA parse_number(&quot;$112,33&quot;) ## [1] 11233 parse_number(&quot;$12.33.21&quot;, locale = locale(grouping_mark = &quot;.&quot;)) ## [1] 123321 parse_double(&quot;12.33&quot;) ## [1] 12.33 parse_double(&quot;12,33&quot;, locale = locale(decimal_mark = &quot;,&quot;)) ## [1] 12.33 str(parse_integer(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;))) ## int [1:3] 1 2 3 5.14 parse_character() parse_character(&quot;Data analytics&quot;, locale = locale(encoding = &quot;Latin1&quot;)) ## [1] &quot;Data analytics&quot; 5.15 parse_guess () 5.16 problems () 5.17 read_delim () 5.18 read_file () 5.19 read_fwf () 5.20 read_lines () 5.21 read_log () 5.22 read_table () 5.23 spec_delim () 5.24 type_convert () 5.25 write_delim () "],
["purrr.html", "6 purrr 6.1 Overview 6.2 Map Family 6.3 Reduce Family", " 6 purrr 6.1 Overview purrr enhances R’s functional programming (FP) toolkit by providing a complete and consistent set of tools for working with functions and vectors. If you’ve never heard of FP before, the best place to start is the family of map() functions which allow you to replace many for loops with code that is both more succinct and easier to read. 6.2 Map Family The complete list of functions within the map family are: map(.x, .f, ...) map_lgl(.x, .f, ...) map_chr(.x, .f, ...) map_int(.x, .f, ...) map_dbl(.x, .f, ...) map_dfr(.x, .f, ..., .id = NULL) map_dfc(.x, .f, ...) walk(.x, .f, ...) Arguments .x: A list or atomic vector .f: A function, formula, or atomic vector If .f is a function, it is used as is If .f is a formula, e.g. ~ .x + 2, it is converted to a function. There are three ways to refer to the arguments: For a single argument function, use . For a two argument function, use .x and .y For more arguments, use ..1, ..2, ..3, etc… 6.2.1 map The map function transforms the input, returning a vector of the same length as the input. map, along with reduce, appear to draw their inspiration from JavaScript. In R, map can be very useful when the programmers wants to use the same function on a list. dplyr has mutate for working with data frames, while purrr specializes in lists. 6.2.1.1 Function Example Lets extract a vector of numbers from an mtcars dataset (mpg). Lets use map to convert that vector into kmpg kmpg &lt;- mpg %&gt;% map(.f = function(x) x * 1.60934) %&gt;% print ## [[1]] ## [1] 33.79614 ## ## [[2]] ## [1] 33.79614 ## ## [[3]] ## [1] 36.69295 ## ## [[4]] ## [1] 34.43988 ## ## [[5]] ## [1] 30.09466 ## ## [[6]] ## [1] 29.12905 ## ## [[7]] ## [1] 23.01356 ## ## [[8]] ## [1] 39.2679 ## ## [[9]] ## [1] 36.69295 ## ## [[10]] ## [1] 30.89933 ## ## [[11]] ## [1] 28.64625 ## ## [[12]] ## [1] 26.39318 ## ## [[13]] ## [1] 27.84158 ## ## [[14]] ## [1] 24.46197 ## ## [[15]] ## [1] 16.73714 ## ## [[16]] ## [1] 16.73714 ## ## [[17]] ## [1] 23.6573 ## ## [[18]] ## [1] 52.14262 ## ## [[19]] ## [1] 48.92394 ## ## [[20]] ## [1] 54.55663 ## ## [[21]] ## [1] 34.60081 ## ## [[22]] ## [1] 24.94477 ## ## [[23]] ## [1] 24.46197 ## ## [[24]] ## [1] 21.40422 ## ## [[25]] ## [1] 30.89933 ## ## [[26]] ## [1] 43.93498 ## ## [[27]] ## [1] 41.84284 ## ## [[28]] ## [1] 48.92394 ## ## [[29]] ## [1] 25.42757 ## ## [[30]] ## [1] 31.704 ## ## [[31]] ## [1] 24.1401 ## ## [[32]] ## [1] 34.43988 data_frame(mpg = c(class(mpg)), kmpg = c(class(kmpg))) %&gt;% kable mpg kmpg numeric list Using map in this instance, returned a list. This may not be preferable in some situations and purrr has built in functions that can return exactly what you are expecting. Our original vector was a numeric vector. We can return a numeric vector using the map_dbl function. Lets re-try the code above using map_dbl. kmpg &lt;- mpg %&gt;% map_dbl(.f = function(x) x * 1.60934) %&gt;% print ## [1] 33.79614 33.79614 36.69295 34.43988 30.09466 29.12905 23.01356 ## [8] 39.26790 36.69295 30.89933 28.64625 26.39318 27.84158 24.46197 ## [15] 16.73714 16.73714 23.65730 52.14262 48.92394 54.55663 34.60081 ## [22] 24.94477 24.46197 21.40422 30.89933 43.93498 41.84284 48.92394 ## [29] 25.42757 31.70400 24.14010 34.43988 data_frame(mpg = c(class(mpg)), kmpg = c(class(kmpg))) %&gt;% kable mpg kmpg numeric numeric As shown, both mpg and kmpg are both numerical vectors. purrr also comes supplies with map_chr, map_dbl, map_dfc (column bind), map_dfr (row bind), map_int, map_lgl. All return vectors except map_dfc and map_dfr which return data frames. 6.2.1.2 Formula Example As stated above, we can also use the map functions with the formula syntax mpg %&gt;% map_dbl(.f = ~ .x * 1.60934) %&gt;% print ## [1] 33.79614 33.79614 36.69295 34.43988 30.09466 29.12905 23.01356 ## [8] 39.26790 36.69295 30.89933 28.64625 26.39318 27.84158 24.46197 ## [15] 16.73714 16.73714 23.65730 52.14262 48.92394 54.55663 34.60081 ## [22] 24.94477 24.46197 21.40422 30.89933 43.93498 41.84284 48.92394 ## [29] 25.42757 31.70400 24.14010 34.43988 6.3 Reduce Family The complete list of functions within the reduce family are: reduce(.x, .f, ..., .init) reduce_right(.x, .f, ..., .init) reduce2(.x, .y, .f, ..., .init) reduce2_right(.x, .y, .f, ..., .init) Arguments .x: A list or atomic vector .f: A 2-argument function. The function will be passed the accumulated value as the first argument and the next value as the second argument. For reduce2(), a 3-argument function. The function will be passed the accumulated value as the first argument, the next value of .x as the second argument, and the next value of .y as the third argument. …: Additional arguments passed on to .f .init: If supplied, will be used as the first value to start the accumulation, rather than using x[[1]]. This is useful if you want to ensure that reduce returns a correct value when .x is empty. If missing, and x is empty, will throw an error .y: For reduce2(), an additional argument that is passed to .f. If init is not set, .y should be 1 element shorter than .x 6.3.1 reduce The reduce function transforms the input into a single value by iteratively applying a binary function. Another function whose inspiration seems to stem from JavaScript. In R, reduce can be useful when you have a list or vector of values that need to be “accumulated” in some form to create a single item. 6.3.1.1 Example Lets pretend that we wanted to create a pipe-delimited string from the row names of our cars data names &lt;- row.names(cars) %&gt;% reduce(.f = function(start, .next) paste(start, .next, sep = &quot;|&quot;)) %&gt;% print ## [1] &quot;1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32&quot; "],
["tibble.html", "7 tibble 7.1 How to create tibble? 7.2 tibble-package () 7.3 add_column () 7.4 add_row () 7.5 enframe () 7.6 frame_matrix () 7.7 glimpse () 7.8 is_tibble () 7.9 new_tibble () 7.10 rownames () 7.11 set_tidy_names () 7.12 tbl_sum () 7.13 tibble-options ()", " 7 tibble Tibbles are a modern take on data frames. They keep the features that have stood the test of time, and drop the features that used to be convenient but are now frustrating (i.e. converting character vectors to factors). 7.1 How to create tibble? 7.1.1 as_tibble() You can coerce a data frame to tibble. as_tibble(nycflights13::airlines) ## # A tibble: 16 x 2 ## carrier name ## &lt;chr&gt; &lt;chr&gt; ## 1 9E Endeavor Air Inc. ## 2 AA American Airlines Inc. ## 3 AS Alaska Airlines Inc. ## 4 B6 JetBlue Airways ## 5 DL Delta Air Lines Inc. ## 6 EV ExpressJet Airlines Inc. ## 7 F9 Frontier Airlines Inc. ## 8 FL AirTran Airways Corporation ## 9 HA Hawaiian Airlines Inc. ## 10 MQ Envoy Air ## 11 OO SkyWest Airlines Inc. ## 12 UA United Air Lines Inc. ## 13 US US Airways Inc. ## 14 VX Virgin America ## 15 WN Southwest Airlines Co. ## 16 YV Mesa Airlines Inc. 7.1.2 tibble() You can create a new tibble from individual vectors with tibble(). tibble( a = 1:15, b = a * 2, c = a ^ 2 + b ) ## # A tibble: 15 x 3 ## a b c ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2. 3. ## 2 2 4. 8. ## 3 3 6. 15. ## 4 4 8. 24. ## 5 5 10. 35. ## 6 6 12. 48. ## 7 7 14. 63. ## 8 8 16. 80. ## 9 9 18. 99. ## 10 10 20. 120. ## 11 11 22. 143. ## 12 12 24. 168. ## 13 13 26. 195. ## 14 14 28. 224. ## 15 15 30. 255. 7.1.3 tribble() Another way to create a tibble is with tribble(), short for transposed tibble. tribble() is customised for data entry in code: column headings are defined by formulas (i.e. they start with ~), and entries are separated by commas. This makes it possible to lay out small amounts of data in easy to read form. tribble( ~x, ~y, ~z, #--|--|---- &quot;a&quot;, 2, 3.6, &quot;b&quot;, 1, 8.5 ) ## # A tibble: 2 x 3 ## x y z ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 2. 3.60 ## 2 b 1. 8.50 It’s possible for a tibble to have column names that are not valid R variable names, aka non-syntactic names. tb &lt;- tibble( `:-)` = &quot;smile&quot;, ` ` = &quot;space&quot;, `5000` = &quot;number&quot; ) Reference Cran R Blog R for Data Science 7.2 tibble-package () 7.3 add_column () 7.4 add_row () 7.5 enframe () 7.6 frame_matrix () 7.7 glimpse () 7.8 is_tibble () 7.9 new_tibble () 7.10 rownames () 7.11 set_tidy_names () 7.12 tbl_sum () 7.13 tibble-options () "],
["stringr.html", "8 stringr 8.1 Pattern matching 8.2 Locate the position of patterns in a string. 8.3 Extract matched groups from a string.", " 8 stringr library(stringr) 8.1 Pattern matching 8.1.1 str_count Count the number of matches in a string Examples: fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pineapple&quot;) str_count(fruit, &quot;a&quot;) ## [1] 1 3 1 1 str_count(fruit, &quot;p&quot;) ## [1] 2 0 1 3 str_count(fruit, &quot;e&quot;) ## [1] 1 0 1 2 str_count(fruit, c(&quot;a&quot;, &quot;b&quot;, &quot;p&quot;, &quot;p&quot;)) ## [1] 1 1 1 3 str_count(c(&quot;a.&quot;, &quot;...&quot;, &quot;.a.a&quot;), &quot;.&quot;) ## [1] 2 3 4 str_count(c(&quot;a.&quot;, &quot;...&quot;, &quot;.a.a&quot;), fixed(&quot;.&quot;)) ## [1] 1 3 2 8.1.2 str_detect Detect the presence or absence of a pattern in a string. Examples: fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pinapple&quot;) str_detect(fruit, &quot;a&quot;) ## [1] TRUE TRUE TRUE TRUE str_detect(fruit, &quot;^a&quot;) ## [1] TRUE FALSE FALSE FALSE str_detect(fruit, &quot;a$&quot;) ## [1] FALSE TRUE FALSE FALSE str_detect(fruit, &quot;b&quot;) ## [1] FALSE TRUE FALSE FALSE str_detect(fruit, &quot;[aeiou]&quot;) ## [1] TRUE TRUE TRUE TRUE ## Also vectorised over pattern str_detect(&quot;aecfg&quot;, letters) ## [1] TRUE FALSE TRUE FALSE TRUE TRUE TRUE FALSE FALSE FALSE FALSE ## [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [23] FALSE FALSE FALSE FALSE 8.1.3 str_extract Extract matching patterns from a string. Examples: shopping_list &lt;- c(&quot;apples x4&quot;, &quot;bag of flour&quot;, &quot;bag of sugar&quot;, &quot;milk x2&quot;) str_extract(shopping_list, &quot;\\\\d&quot;) ## [1] &quot;4&quot; NA NA &quot;2&quot; str_extract(shopping_list, &quot;[a-z]+&quot;) ## [1] &quot;apples&quot; &quot;bag&quot; &quot;bag&quot; &quot;milk&quot; str_extract(shopping_list, &quot;[a-z]{1,4}&quot;) ## [1] &quot;appl&quot; &quot;bag&quot; &quot;bag&quot; &quot;milk&quot; str_extract(shopping_list, &quot;\\\\b[a-z]{1,4}\\\\b&quot;) ## [1] NA &quot;bag&quot; &quot;bag&quot; &quot;milk&quot; ## Extract all matches str_extract_all(shopping_list, &quot;[a-z]+&quot;) ## [[1]] ## [1] &quot;apples&quot; &quot;x&quot; ## ## [[2]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;flour&quot; ## ## [[3]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;sugar&quot; ## ## [[4]] ## [1] &quot;milk&quot; &quot;x&quot; str_extract_all(shopping_list, &quot;\\\\b[a-z]+\\\\b&quot;) ## [[1]] ## [1] &quot;apples&quot; ## ## [[2]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;flour&quot; ## ## [[3]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;sugar&quot; ## ## [[4]] ## [1] &quot;milk&quot; str_extract_all(shopping_list, &quot;\\\\d&quot;) ## [[1]] ## [1] &quot;4&quot; ## ## [[2]] ## character(0) ## ## [[3]] ## character(0) ## ## [[4]] ## [1] &quot;2&quot; ## Simplify results into character matrix str_extract_all(shopping_list, &quot;\\\\b[a-z]+\\\\b&quot;, simplify = TRUE) ## [,1] [,2] [,3] ## [1,] &quot;apples&quot; &quot;&quot; &quot;&quot; ## [2,] &quot;bag&quot; &quot;of&quot; &quot;flour&quot; ## [3,] &quot;bag&quot; &quot;of&quot; &quot;sugar&quot; ## [4,] &quot;milk&quot; &quot;&quot; &quot;&quot; str_extract_all(shopping_list, &quot;\\\\d&quot;, simplify = TRUE) ## [,1] ## [1,] &quot;4&quot; ## [2,] &quot;&quot; ## [3,] &quot;&quot; ## [4,] &quot;2&quot; ## Extract all words str_extract_all(&quot;This is, suprisingly, a sentence.&quot;, boundary(&quot;word&quot;)) ## [[1]] ## [1] &quot;This&quot; &quot;is&quot; &quot;suprisingly&quot; &quot;a&quot; &quot;sentence&quot; 8.1.4 str_extract_all str_extract_all(string, pattern, simplify = FALSE) Examples: shopping_list &lt;- c(&quot;apples x4&quot;, &quot;bag of flour&quot;, &quot;bag of sugar&quot;, &quot;milk x2&quot;) str_extract(shopping_list, &quot;\\\\d&quot;) ## [1] &quot;4&quot; NA NA &quot;2&quot; str_extract(shopping_list, &quot;[a-z]+&quot;) ## [1] &quot;apples&quot; &quot;bag&quot; &quot;bag&quot; &quot;milk&quot; str_extract(shopping_list, &quot;[a-z]{1,4}&quot;) ## [1] &quot;appl&quot; &quot;bag&quot; &quot;bag&quot; &quot;milk&quot; str_extract(shopping_list, &quot;\\\\b[a-z]{1,4}\\\\b&quot;) ## [1] NA &quot;bag&quot; &quot;bag&quot; &quot;milk&quot; ## Extract all matches str_extract_all(shopping_list, &quot;[a-z]+&quot;) ## [[1]] ## [1] &quot;apples&quot; &quot;x&quot; ## ## [[2]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;flour&quot; ## ## [[3]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;sugar&quot; ## ## [[4]] ## [1] &quot;milk&quot; &quot;x&quot; str_extract_all(shopping_list, &quot;\\\\b[a-z]+\\\\b&quot;) ## [[1]] ## [1] &quot;apples&quot; ## ## [[2]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;flour&quot; ## ## [[3]] ## [1] &quot;bag&quot; &quot;of&quot; &quot;sugar&quot; ## ## [[4]] ## [1] &quot;milk&quot; str_extract_all(shopping_list, &quot;\\\\d&quot;) ## [[1]] ## [1] &quot;4&quot; ## ## [[2]] ## character(0) ## ## [[3]] ## character(0) ## ## [[4]] ## [1] &quot;2&quot; str_extract_all(shopping_list, &quot;\\\\b[a-z]+\\\\b&quot;, simplify = TRUE) ## [,1] [,2] [,3] ## [1,] &quot;apples&quot; &quot;&quot; &quot;&quot; ## [2,] &quot;bag&quot; &quot;of&quot; &quot;flour&quot; ## [3,] &quot;bag&quot; &quot;of&quot; &quot;sugar&quot; ## [4,] &quot;milk&quot; &quot;&quot; &quot;&quot; str_extract_all(shopping_list, &quot;\\\\d&quot;, simplify = TRUE) ## [,1] ## [1,] &quot;4&quot; ## [2,] &quot;&quot; ## [3,] &quot;&quot; ## [4,] &quot;2&quot; str_extract_all(&quot;This is, suprisingly, a sentence.&quot;, boundary(&quot;word&quot;)) ## [[1]] ## [1] &quot;This&quot; &quot;is&quot; &quot;suprisingly&quot; &quot;a&quot; &quot;sentence&quot; 8.2 Locate the position of patterns in a string. 8.2.1 str_locate(string, pattern) For str_locate, an integer matrix. First column gives start postion of match, and second column gives end position. For str_locate_all a list of integer matrices. Vectorised over string and pattern. If the match is of length 0, (e.g. from a special match like $) end will be one character less than start. Examples str_locate and str_locate_all: fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pineapple&quot;) str_locate(fruit, &quot;$&quot;) ## start end ## [1,] 6 5 ## [2,] 7 6 ## [3,] 5 4 ## [4,] 10 9 str_locate(fruit, &quot;a&quot;) ## start end ## [1,] 1 1 ## [2,] 2 2 ## [3,] 3 3 ## [4,] 5 5 str_locate(fruit, &quot;e&quot;) ## start end ## [1,] 5 5 ## [2,] NA NA ## [3,] 2 2 ## [4,] 4 4 str_locate(fruit, c(&quot;a&quot;, &quot;b&quot;, &quot;p&quot;, &quot;p&quot;)) ## start end ## [1,] 1 1 ## [2,] 1 1 ## [3,] 1 1 ## [4,] 1 1 str_locate_all(fruit, &quot;a&quot;) ## [[1]] ## start end ## [1,] 1 1 ## ## [[2]] ## start end ## [1,] 2 2 ## [2,] 4 4 ## [3,] 6 6 ## ## [[3]] ## start end ## [1,] 3 3 ## ## [[4]] ## start end ## [1,] 5 5 str_locate_all(fruit, &quot;e&quot;) ## [[1]] ## start end ## [1,] 5 5 ## ## [[2]] ## start end ## ## [[3]] ## start end ## [1,] 2 2 ## ## [[4]] ## start end ## [1,] 4 4 ## [2,] 9 9 ## Find location of every character str_locate_all(fruit, &quot;&quot;) ## [[1]] ## start end ## [1,] 1 1 ## [2,] 2 2 ## [3,] 3 3 ## [4,] 4 4 ## [5,] 5 5 ## ## [[2]] ## start end ## [1,] 1 1 ## [2,] 2 2 ## [3,] 3 3 ## [4,] 4 4 ## [5,] 5 5 ## [6,] 6 6 ## ## [[3]] ## start end ## [1,] 1 1 ## [2,] 2 2 ## [3,] 3 3 ## [4,] 4 4 ## ## [[4]] ## start end ## [1,] 1 1 ## [2,] 2 2 ## [3,] 3 3 ## [4,] 4 4 ## [5,] 5 5 ## [6,] 6 6 ## [7,] 7 7 ## [8,] 8 8 ## [9,] 9 9 8.3 Extract matched groups from a string. Vectorised over string and pattern. str_match(string, pattern) str_match_all(string, pattern) For str_match, a character matrix. First column is the complete match, followed by one column for each capture group. For str_match_all, a list of character matrices. Examples: strings &lt;- c(&quot; 219 733 8965&quot;, &quot;329-293-8753 &quot;, &quot;banana&quot;, &quot;595 794 7569&quot;, &quot;387 287 6718&quot;, &quot;apple&quot;, &quot;233.398.9187 &quot;, &quot;482 952 3315&quot;, &quot;239 923 8115 and 842 566 4692&quot;, &quot;Work: 579-499-7527&quot;, &quot;$1000&quot;, &quot;Home: 543.355.3679&quot;) phone &lt;- &quot;([2-9][0-9]{2})[- .]([0-9]{3})[- .]([0-9]{4})&quot; str_extract(strings, phone) ## [1] &quot;219 733 8965&quot; &quot;329-293-8753&quot; NA &quot;595 794 7569&quot; ## [5] &quot;387 287 6718&quot; NA &quot;233.398.9187&quot; &quot;482 952 3315&quot; ## [9] &quot;239 923 8115&quot; &quot;579-499-7527&quot; NA &quot;543.355.3679&quot; str_match(strings, phone) ## [,1] [,2] [,3] [,4] ## [1,] &quot;219 733 8965&quot; &quot;219&quot; &quot;733&quot; &quot;8965&quot; ## [2,] &quot;329-293-8753&quot; &quot;329&quot; &quot;293&quot; &quot;8753&quot; ## [3,] NA NA NA NA ## [4,] &quot;595 794 7569&quot; &quot;595&quot; &quot;794&quot; &quot;7569&quot; ## [5,] &quot;387 287 6718&quot; &quot;387&quot; &quot;287&quot; &quot;6718&quot; ## [6,] NA NA NA NA ## [7,] &quot;233.398.9187&quot; &quot;233&quot; &quot;398&quot; &quot;9187&quot; ## [8,] &quot;482 952 3315&quot; &quot;482&quot; &quot;952&quot; &quot;3315&quot; ## [9,] &quot;239 923 8115&quot; &quot;239&quot; &quot;923&quot; &quot;8115&quot; ## [10,] &quot;579-499-7527&quot; &quot;579&quot; &quot;499&quot; &quot;7527&quot; ## [11,] NA NA NA NA ## [12,] &quot;543.355.3679&quot; &quot;543&quot; &quot;355&quot; &quot;3679&quot; ## Extract/match all str_extract_all(strings, phone) ## [[1]] ## [1] &quot;219 733 8965&quot; ## ## [[2]] ## [1] &quot;329-293-8753&quot; ## ## [[3]] ## character(0) ## ## [[4]] ## [1] &quot;595 794 7569&quot; ## ## [[5]] ## [1] &quot;387 287 6718&quot; ## ## [[6]] ## character(0) ## ## [[7]] ## [1] &quot;233.398.9187&quot; ## ## [[8]] ## [1] &quot;482 952 3315&quot; ## ## [[9]] ## [1] &quot;239 923 8115&quot; &quot;842 566 4692&quot; ## ## [[10]] ## [1] &quot;579-499-7527&quot; ## ## [[11]] ## character(0) ## ## [[12]] ## [1] &quot;543.355.3679&quot; str_match_all(strings, phone) ## [[1]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;219 733 8965&quot; &quot;219&quot; &quot;733&quot; &quot;8965&quot; ## ## [[2]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;329-293-8753&quot; &quot;329&quot; &quot;293&quot; &quot;8753&quot; ## ## [[3]] ## [,1] [,2] [,3] [,4] ## ## [[4]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;595 794 7569&quot; &quot;595&quot; &quot;794&quot; &quot;7569&quot; ## ## [[5]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;387 287 6718&quot; &quot;387&quot; &quot;287&quot; &quot;6718&quot; ## ## [[6]] ## [,1] [,2] [,3] [,4] ## ## [[7]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;233.398.9187&quot; &quot;233&quot; &quot;398&quot; &quot;9187&quot; ## ## [[8]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;482 952 3315&quot; &quot;482&quot; &quot;952&quot; &quot;3315&quot; ## ## [[9]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;239 923 8115&quot; &quot;239&quot; &quot;923&quot; &quot;8115&quot; ## [2,] &quot;842 566 4692&quot; &quot;842&quot; &quot;566&quot; &quot;4692&quot; ## ## [[10]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;579-499-7527&quot; &quot;579&quot; &quot;499&quot; &quot;7527&quot; ## ## [[11]] ## [,1] [,2] [,3] [,4] ## ## [[12]] ## [,1] [,2] [,3] [,4] ## [1,] &quot;543.355.3679&quot; &quot;543&quot; &quot;355&quot; &quot;3679&quot; x &lt;- c(&quot;&lt;a&gt; &lt;b&gt;&quot;, &quot;&lt;a&gt; &lt;&gt;&quot;, &quot;&lt;a&gt;&quot;, &quot;&quot;, NA) str_match(x, &quot;&lt;(.*?)&gt; &lt;(.*?)&gt;&quot;) ## [,1] [,2] [,3] ## [1,] &quot;&lt;a&gt; &lt;b&gt;&quot; &quot;a&quot; &quot;b&quot; ## [2,] &quot;&lt;a&gt; &lt;&gt;&quot; &quot;a&quot; &quot;&quot; ## [3,] NA NA NA ## [4,] NA NA NA ## [5,] NA NA NA str_match_all(x, &quot;&lt;(.*?)&gt;&quot;) ## [[1]] ## [,1] [,2] ## [1,] &quot;&lt;a&gt;&quot; &quot;a&quot; ## [2,] &quot;&lt;b&gt;&quot; &quot;b&quot; ## ## [[2]] ## [,1] [,2] ## [1,] &quot;&lt;a&gt;&quot; &quot;a&quot; ## [2,] &quot;&lt;&gt;&quot; &quot;&quot; ## ## [[3]] ## [,1] [,2] ## [1,] &quot;&lt;a&gt;&quot; &quot;a&quot; ## ## [[4]] ## [,1] [,2] ## ## [[5]] ## [,1] [,2] ## [1,] NA NA str_extract(x, &quot;&lt;.*?&gt;&quot;) ## [1] &quot;&lt;a&gt;&quot; &quot;&lt;a&gt;&quot; &quot;&lt;a&gt;&quot; NA NA str_extract_all(x, &quot;&lt;.*?&gt;&quot;) ## [[1]] ## [1] &quot;&lt;a&gt;&quot; &quot;&lt;b&gt;&quot; ## ## [[2]] ## [1] &quot;&lt;a&gt;&quot; &quot;&lt;&gt;&quot; ## ## [[3]] ## [1] &quot;&lt;a&gt;&quot; ## ## [[4]] ## character(0) ## ## [[5]] ## [1] NA 8.3.1 str_to_upper () str_to_upper (string) Convert case of a string. Example: exstring &lt;- &quot;the example string&quot; str_to_upper(exstring) ## [1] &quot;THE EXAMPLE STRING&quot; 8.3.2 invert_match () invert_match (string) Invert a matrix of match locations to match the opposite of what was previously matched. Example: numbers &lt;- &quot;1 and 2 and 4 and 456&quot; num_loc &lt;- str_locate_all(numbers, &quot;[0-9]+&quot;)[[1]] str_sub(numbers, num_loc[, &quot;start&quot;], num_loc[, &quot;end&quot;]) ## [1] &quot;1&quot; &quot;2&quot; &quot;4&quot; &quot;456&quot; text_loc &lt;- invert_match(num_loc) str_sub(numbers, text_loc[, &quot;start&quot;], text_loc[, &quot;end&quot;]) ## [1] &quot;&quot; &quot; and &quot; &quot; and &quot; &quot; and &quot; &quot;&quot; 8.3.3 modifiers () 8.3.4 stringr-data () 8.3.5 str_c () 8.3.6 str_conv () str_conv(string, encoding) This is a convenient way to override the current encoding of a string. x &lt;- rawToChar(as.raw(177)) x ## [1] &quot;\\xb1&quot; str_conv(x, &quot;ISO-8859-2&quot;) ## [1] &quot;ą&quot; str_conv(x, &quot;ISO-8859-1&quot;) ## [1] &quot;±&quot; 8.3.7 str_count () str_count(string, pattern = “”) Count The Number Of Matches In A String. Example: fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;, &quot;pineapple&quot;) str_count(fruit, &quot;a&quot;) ## [1] 1 3 1 1 str_count(fruit, &quot;p&quot;) ## [1] 2 0 1 3 str_count(fruit, &quot;e&quot;) ## [1] 1 0 1 2 str_count(fruit, c(&quot;a&quot;, &quot;b&quot;, &quot;p&quot;, &quot;p&quot;)) ## [1] 1 1 1 3 8.3.8 str_dup () str_dup(string, times) Duplicate And Concatenate Strings Within A Character Vector. Example: fruit &lt;- c(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;) str_dup(fruit, 2) ## [1] &quot;appleapple&quot; &quot;pearpear&quot; &quot;bananabanana&quot; str_dup(fruit, 1:3) ## [1] &quot;apple&quot; &quot;pearpear&quot; &quot;bananabananabanana&quot; str_c(&quot;ba&quot;, str_dup(&quot;na&quot;, 0:5)) ## [1] &quot;ba&quot; &quot;bana&quot; &quot;banana&quot; &quot;bananana&quot; ## [5] &quot;banananana&quot; &quot;bananananana&quot; 8.3.9 str_flatten () str_flatten(string, collapse = “”) Flatten a string Example: str_flatten(letters) ## [1] &quot;abcdefghijklmnopqrstuvwxyz&quot; str_flatten(letters, &quot;-&quot;) ## [1] &quot;a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z&quot; 8.3.10 str_glue () str_glue(…, .sep = “”, .envir = parent.frame()) These functions are wrappers around glue::glue() and glue::glue_data(), which provide a powerful and elegant syntax for interpolating strings. These wrappers provide a small set of the full options. Use the functions directly from glue for more control. Example: name &lt;- &quot;Fred&quot; age &lt;- 50 anniversary &lt;- as.Date(&quot;1991-10-12&quot;) str_glue( &quot;My name is {name}, &quot;, &quot;my age next year is {age + 1}, &quot;, &quot;and my anniversary is {format(anniversary, &#39;%A, %B %d, %Y&#39;)}.&quot; ) ## My name is Fred, my age next year is 51, and my anniversary is Saturday, October 12, 1991. 8.3.11 str_length () str_length(string) Returns The Length Of A String. Example: str_length(c(&quot;i&quot;, &quot;like&quot;, &quot;Ice Cream&quot;, NA)) ## [1] 1 4 9 NA 8.3.12 str_match () 8.3.13 str_order () str_order takes a character vector as input and returns an integer vector. It can also sort digits numerically if numeric = TRUE is flagged (default is FALSE). Example: groceries &lt;- c(&quot;Apples&quot;, &quot;Oranges&quot;, &quot;Bananas&quot;, &quot;Watermelon&quot;, &quot;Strawberry&quot;) # Return integer vector str_order(groceries) ## [1] 1 3 2 5 4 # How to sort groceries[str_order(groceries)] ## [1] &quot;Apples&quot; &quot;Bananas&quot; &quot;Oranges&quot; &quot;Strawberry&quot; &quot;Watermelon&quot; # Numerical sort numbers &lt;- c(&quot;1000&quot;, &quot;500000&quot;, &quot;2ab&quot;, &quot;117&quot;) numbers[str_order(numbers, numeric = TRUE)] ## [1] &quot;2ab&quot; &quot;117&quot; &quot;1000&quot; &quot;500000&quot; numbers[str_order(numbers)] ## [1] &quot;1000&quot; &quot;117&quot; &quot;2ab&quot; &quot;500000&quot; 8.3.14 str_pad () Add characters (typically &quot; “) to a string at the specified location such that its width is &gt;= the minimum specified width *str_pad(string, width, side = c(“left”, “right”, “both”), pad = &quot; “)* my.string &lt;- &quot;this test string is good!!!&quot; str_pad(my.string,50,&quot;left&quot;) ## [1] &quot; this test string is good!!!&quot; str_pad(my.string,50,&quot;right&quot;) ## [1] &quot;this test string is good!!! &quot; 8.3.15 str_remove () 8.3.16 str_replace () str_replace can be used to replace a pattern within a string and takes the form: str_replace(string,pattern,replacement) Where “string” is your input string, “pattern” is the pattern that you are looking to replace, which can be either a regular expression, or a fixed string, and replacement is your desired replacement value. my.string &lt;- &quot;this test string is good!!!&quot; #replace exclamation marks with a period via regex matching str_replace(my.string,&#39;\\\\!+&#39;,&quot;.&quot;) ## [1] &quot;this test string is good.&quot; #replace a fixed string by using fixed() str_replace(my.string,&quot;good&quot;,&quot;great&quot;) ## [1] &quot;this test string is great!!!&quot; 8.3.17 str_replace_na () 8.3.18 str_split () str_split splits a string into multiple pieces based on a defined pattern. It splits the target string on as many occurences of the pattern as are found, unless instructed otherwise. Also note that the pattern characters are not returns in the split strings. It takes the following form: str_split(my.string,pattern,n) my.string &lt;- &quot;this test string is good!!!&quot; #split the string on spaces, to a max of 3 splits str_split(my.string,&quot;[[:space:]]&quot;,n=3) ## [[1]] ## [1] &quot;this&quot; &quot;test&quot; &quot;string is good!!!&quot; #Split my.string on the letter &quot;e&quot; str_split(my.string,&#39;e&#39;) ## [[1]] ## [1] &quot;this t&quot; &quot;st string is good!!!&quot; 8.3.19 str_sub () Extract a substring from a character vector. This function allows you to pull pieces out of larger strings based on an index. my.string &lt;- &quot;this test string is good!!!&quot; #get the first 10 characters of the string str_sub(my.string,end=10) ## [1] &quot;this test &quot; #get the first 5th to the 10th characters of the string str_sub(my.string,5,10) ## [1] &quot; test &quot; #get the last 10 characters of the string using a negative index str_sub(my.string,-10) ## [1] &quot;is good!!!&quot; 8.3.20 str_subset () 8.3.21 str_trim () Removes whitespace from the start of a string. my.string &lt;- &quot; this test string is good!!!&quot; #strip the whitespace from the string str_trim(my.string) ## [1] &quot;this test string is good!!!&quot; 8.3.22 str_trunc () Truncate a character string. Essentially this function reduces a string to the specified number of characters or less. str_trunc(string, width, side = c(“right”, “left”, “center”),ellipsis = “…”) my.string &lt;- &quot;this test string is good!!!&quot; #truncate the string down to the specified number of characters, from the location specified str_trunc(my.string,15,&quot;right&quot;) ## [1] &quot;this test st...&quot; str_trunc(my.string,15,&quot;center&quot;) ## [1] &quot;this t...ood!!!&quot; 8.3.23 str_view () 8.3.24 str_wrap () 8.3.25 word () "],
["forcats.html", "9 forcats 9.1 as_factor () 9.2 fct_anonv () 9.3 fct_c () 9.4 fct_collapse () 9.5 fct_count () 9.6 fct_drop () 9.7 fct_expand () 9.8 fct_explicit_na () 9.9 fct_inorder () 9.10 fct_lump () 9.11 fct_other () 9.12 fct_recode () 9.13 fct_relabel () 9.14 fct_relevel () 9.15 fct_reorder () 9.16 fct_rev () 9.17 fct_shift () 9.18 fct_shuffle () 9.19 fct_unify () 9.20 fct_unique () 9.21 gss_cat () 9.22 lvls () 9.23 lvls_union ()", " 9 forcats 9.1 as_factor () 9.2 fct_anonv () 9.3 fct_c () 9.4 fct_collapse () 9.5 fct_count () 9.6 fct_drop () 9.7 fct_expand () 9.8 fct_explicit_na () 9.9 fct_inorder () 9.10 fct_lump () 9.11 fct_other () 9.12 fct_recode () 9.13 fct_relabel () 9.14 fct_relevel () 9.15 fct_reorder () 9.16 fct_rev () 9.17 fct_shift () 9.18 fct_shuffle () 9.19 fct_unify () 9.20 fct_unique () 9.21 gss_cat () 9.22 lvls () 9.23 lvls_union () "],
["lubridate.html", "10 lubridate 10.1 ymd(): 10.2 mdy(): 10.3 dmy(): 10.4 ymd_hms(): 10.5 Additional Lubridate Functions:", " 10 lubridate The lubridate package makes working with date-time data easier. Base R commands for date-times are generally unintuitive not robust. According to Hadley Wickham, “lubridate has a consistent, memorable syntax, that makes working with dates fun instead of frustrating.” For additional information use help(package = lubridate) to bring up an overview of the package and its functions. Load Packages: library(lubridate) Load data from the FiveThirtyEight article “Some People Are Too Superstitious To Have A Baby On Friday The 13th” Since it is fairly clean data, I will create additional columns to showcase lubridate functionality below I will use the now(), hour(), minute() and second() functions to add addditional metadata to the dataframe. Please see definitions below Once the new columns are added, I will remove the original clean columns US_births_2000 &lt;- read_csv(&quot;https://raw.githubusercontent.com/fivethirtyeight/data/master/births/US_births_1994-2003_CDC_NCHS.csv&quot;)%&gt;% filter(year == 2000)%&gt;% mutate(year = as.character(year), month = as.character(month), date_of_month = as.character(date_of_month)) %&gt;% mutate(ymd.raw = paste(year, month, date_of_month, sep = &#39;-&#39;))%&gt;% mutate(mdy.raw = paste(month,date_of_month,year, sep = &#39;-&#39;))%&gt;% mutate(dmy.raw = paste(date_of_month,month, year,sep = &#39;-&#39;))%&gt;% mutate(ymd.hms.raw = paste(year,month,date_of_month, hour(now()), minute(now()), second(now()),sep = &#39;-&#39;))%&gt;% select(-c(year, month, date_of_month)) kable(head(US_births_2000,10), caption = &quot;2000 Birth Data&quot;) Table 10.1: 2000 Birth Data day_of_week births ymd.raw mdy.raw dmy.raw ymd.hms.raw 6 8843 2000-1-1 1-1-2000 1-1-2000 2000-1-1-13-50-6.64746308326721 7 7816 2000-1-2 1-2-2000 2-1-2000 2000-1-2-13-50-6.64746308326721 1 11123 2000-1-3 1-3-2000 3-1-2000 2000-1-3-13-50-6.64746308326721 2 12703 2000-1-4 1-4-2000 4-1-2000 2000-1-4-13-50-6.64746308326721 3 12240 2000-1-5 1-5-2000 5-1-2000 2000-1-5-13-50-6.64746308326721 4 12260 2000-1-6 1-6-2000 6-1-2000 2000-1-6-13-50-6.64746308326721 5 12280 2000-1-7 1-7-2000 7-1-2000 2000-1-7-13-50-6.64746308326721 6 8750 2000-1-8 1-8-2000 8-1-2000 2000-1-8-13-50-6.64746308326721 7 7736 2000-1-9 1-9-2000 9-1-2000 2000-1-9-13-50-6.64746308326721 1 11418 2000-1-10 1-10-2000 10-1-2000 2000-1-10-13-50-6.64746308326721 10.1 ymd(): parses in order - year, month, date. I will apply to the “ymd.raw” column and save the results as “ymd.clean” cleaned_date_df &lt;- US_births_2000%&gt;% mutate(ymd.clean = ymd(ymd.raw), ymd.type = class(ymd.clean))%&gt;% select(-c(ymd.raw)) kable(head(cleaned_date_df,10), caption = &quot;ymd() results&quot;) Table 10.2: ymd() results day_of_week births mdy.raw dmy.raw ymd.hms.raw ymd.clean ymd.type 6 8843 1-1-2000 1-1-2000 2000-1-1-13-50-6.64746308326721 2000-01-01 Date 7 7816 1-2-2000 2-1-2000 2000-1-2-13-50-6.64746308326721 2000-01-02 Date 1 11123 1-3-2000 3-1-2000 2000-1-3-13-50-6.64746308326721 2000-01-03 Date 2 12703 1-4-2000 4-1-2000 2000-1-4-13-50-6.64746308326721 2000-01-04 Date 3 12240 1-5-2000 5-1-2000 2000-1-5-13-50-6.64746308326721 2000-01-05 Date 4 12260 1-6-2000 6-1-2000 2000-1-6-13-50-6.64746308326721 2000-01-06 Date 5 12280 1-7-2000 7-1-2000 2000-1-7-13-50-6.64746308326721 2000-01-07 Date 6 8750 1-8-2000 8-1-2000 2000-1-8-13-50-6.64746308326721 2000-01-08 Date 7 7736 1-9-2000 9-1-2000 2000-1-9-13-50-6.64746308326721 2000-01-09 Date 1 11418 1-10-2000 10-1-2000 2000-1-10-13-50-6.64746308326721 2000-01-10 Date 10.2 mdy(): parses in order- month, date, year. I will apply to the “mdy.raw” column and save the results as “mdy.clean.” The mdy() function will save the results as year-month-date. This is helpful when trying to normalize data. As you can see below, the “ymd.clean” =“mdy.clean” cleaned_date_df &lt;- cleaned_date_df%&gt;% mutate(mdy.clean = mdy(mdy.raw))%&gt;% select(-c(mdy.raw)) kable(head(cleaned_date_df,10), caption = &quot;mdy() results&quot;) Table 10.3: mdy() results day_of_week births dmy.raw ymd.hms.raw ymd.clean ymd.type mdy.clean 6 8843 1-1-2000 2000-1-1-13-50-6.64746308326721 2000-01-01 Date 2000-01-01 7 7816 2-1-2000 2000-1-2-13-50-6.64746308326721 2000-01-02 Date 2000-01-02 1 11123 3-1-2000 2000-1-3-13-50-6.64746308326721 2000-01-03 Date 2000-01-03 2 12703 4-1-2000 2000-1-4-13-50-6.64746308326721 2000-01-04 Date 2000-01-04 3 12240 5-1-2000 2000-1-5-13-50-6.64746308326721 2000-01-05 Date 2000-01-05 4 12260 6-1-2000 2000-1-6-13-50-6.64746308326721 2000-01-06 Date 2000-01-06 5 12280 7-1-2000 2000-1-7-13-50-6.64746308326721 2000-01-07 Date 2000-01-07 6 8750 8-1-2000 2000-1-8-13-50-6.64746308326721 2000-01-08 Date 2000-01-08 7 7736 9-1-2000 2000-1-9-13-50-6.64746308326721 2000-01-09 Date 2000-01-09 1 11418 10-1-2000 2000-1-10-13-50-6.64746308326721 2000-01-10 Date 2000-01-10 10.3 dmy(): parses in order- day, month, year. The dmy() function will save the results as year-month-date. This is helpful when trying to normalize data. As you can see below, the “ymd.clean” = “dmy.clean” cleaned_date_df &lt;- cleaned_date_df%&gt;% mutate(dmy.clean = dmy(dmy.raw))%&gt;% select(-c(dmy.raw)) kable(head(cleaned_date_df,10), caption = &quot;dmy() results&quot;) Table 10.4: dmy() results day_of_week births ymd.hms.raw ymd.clean ymd.type mdy.clean dmy.clean 6 8843 2000-1-1-13-50-6.64746308326721 2000-01-01 Date 2000-01-01 2000-01-01 7 7816 2000-1-2-13-50-6.64746308326721 2000-01-02 Date 2000-01-02 2000-01-02 1 11123 2000-1-3-13-50-6.64746308326721 2000-01-03 Date 2000-01-03 2000-01-03 2 12703 2000-1-4-13-50-6.64746308326721 2000-01-04 Date 2000-01-04 2000-01-04 3 12240 2000-1-5-13-50-6.64746308326721 2000-01-05 Date 2000-01-05 2000-01-05 4 12260 2000-1-6-13-50-6.64746308326721 2000-01-06 Date 2000-01-06 2000-01-06 5 12280 2000-1-7-13-50-6.64746308326721 2000-01-07 Date 2000-01-07 2000-01-07 6 8750 2000-1-8-13-50-6.64746308326721 2000-01-08 Date 2000-01-08 2000-01-08 7 7736 2000-1-9-13-50-6.64746308326721 2000-01-09 Date 2000-01-09 2000-01-09 1 11418 2000-1-10-13-50-6.64746308326721 2000-01-10 Date 2000-01-10 2000-01-10 10.4 ymd_hms(): parses in order- year, month, day _ hour, minute, second cleaned_date_df &lt;- cleaned_date_df%&gt;% mutate(ymd.hms.clean = ymd_hms(ymd.hms.raw))%&gt;% select(-c(ymd.hms.raw)) kable(head(cleaned_date_df,10), caption = &quot;ymd_hms() results&quot;) Table 10.5: ymd_hms() results day_of_week births ymd.clean ymd.type mdy.clean dmy.clean ymd.hms.clean 6 8843 2000-01-01 Date 2000-01-01 2000-01-01 2000-01-01 13:50:06 7 7816 2000-01-02 Date 2000-01-02 2000-01-02 2000-01-02 13:50:06 1 11123 2000-01-03 Date 2000-01-03 2000-01-03 2000-01-03 13:50:06 2 12703 2000-01-04 Date 2000-01-04 2000-01-04 2000-01-04 13:50:06 3 12240 2000-01-05 Date 2000-01-05 2000-01-05 2000-01-05 13:50:06 4 12260 2000-01-06 Date 2000-01-06 2000-01-06 2000-01-06 13:50:06 5 12280 2000-01-07 Date 2000-01-07 2000-01-07 2000-01-07 13:50:06 6 8750 2000-01-08 Date 2000-01-08 2000-01-08 2000-01-08 13:50:06 7 7736 2000-01-09 Date 2000-01-09 2000-01-09 2000-01-09 13:50:06 1 11418 2000-01-10 Date 2000-01-10 2000-01-10 2000-01-10 13:50:06 cleaned_date_df &lt;- cleaned_date_df%&gt;% mutate(wday.clean = wday(ymd.clean))%&gt;% select(-c(day_of_week)) kable(head(cleaned_date_df,10), caption = &quot;wday() results&quot;) Table 10.6: wday() results births ymd.clean ymd.type mdy.clean dmy.clean ymd.hms.clean wday.clean 8843 2000-01-01 Date 2000-01-01 2000-01-01 2000-01-01 13:50:06 7 7816 2000-01-02 Date 2000-01-02 2000-01-02 2000-01-02 13:50:06 1 11123 2000-01-03 Date 2000-01-03 2000-01-03 2000-01-03 13:50:06 2 12703 2000-01-04 Date 2000-01-04 2000-01-04 2000-01-04 13:50:06 3 12240 2000-01-05 Date 2000-01-05 2000-01-05 2000-01-05 13:50:06 4 12260 2000-01-06 Date 2000-01-06 2000-01-06 2000-01-06 13:50:06 5 12280 2000-01-07 Date 2000-01-07 2000-01-07 2000-01-07 13:50:06 6 8750 2000-01-08 Date 2000-01-08 2000-01-08 2000-01-08 13:50:06 7 7736 2000-01-09 Date 2000-01-09 2000-01-09 2000-01-09 13:50:06 1 11418 2000-01-10 Date 2000-01-10 2000-01-10 2000-01-10 13:50:06 2 10.5 Additional Lubridate Functions: 10.5.1 Extract Information From Dates: tody() : returns today’s date year(): returns the year month(): returns the month Sys.getlocale() ## [1] &quot;en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8&quot; this_day &lt;- today() this_day ## [1] &quot;2018-05-09&quot; 10.5.2 Date-Time Information: these were used to create the base dataframe day(): returns the day wday(): day of the week now(): date-time of the exact moment hour(): hour of the exact moment minute(): minute of the exact moment second(): second of the exact moment "],
["references.html", "References", " References "]
]
